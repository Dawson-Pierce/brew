clear; clc; close all

%% Target setup

mean = [0; 0; 1; 1];
cov = diag([0.001, 0.001, 1, 1]); % since generating measurements from gaussian, this dictates measurement resolution

target = BREW.distributions.Gaussian(mean,cov); 


%% Filter setup

dyn = BREW.dynamics.Integrator_2D();

est = BREW.distributions.TrajectoryGaussian(1,target.sample(),cov); % Randomize mean initialization

ekf = BREW.filters.TrajectoryGaussianEKF('dyn_obj',dyn,'process_noise',0.01 * eye(4),'H',[1 0 0 0; 0 1 0 0], 'measurement_noise', 2 * [1; 1]);

dt = 0.1;

t = 0:1:100;


%% Running the loop

meas_hst = [];

for k = 1:length(t)
    target.mean = dyn.propagateState(dt,target.mean);
    meas = target.sample_measurements([1 2]);

    meas_hst = [meas_hst, meas];

    est = ekf.predict(dt,est); % Predict the next state
    est = ekf.correct(dt, meas, est); % Update the estimate with the new measurements

    % Plotting
    scatter(meas_hst(1,:),meas_hst(2,:),'w*'); grid on; hold off
    xlim([-5 15])
    ylim([-5 15])

    est.plot([1 2],'c','r-','lineWidth',2); hold on
    
    drawnow; 
end